<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.

// Grid dimension
const int N=10;
const int M=10;

// These are the cell states, to understand whether it is occupied or not.
const int EMPTY = 0;
const int ROBOT = 1;
const int POD = 2;
const int POD_AND_ROBOT = 3;

// Status of the pod.
const int POD_FREE = 0;
const int POD_OCCUPIED = 1;

// Max number of tasks
const int MAX_T = 10;

// Number of pods
const int PODS_N = N*M - (N/2)*M - (N/2 + N%2)*4;

// This is the grid representing the map.
int grid[N][M];

// Position and status of each pod.
// The second array is necessary to understand the position of the pod and the status (free/occupied).
// The first array is simply a way of giving the id to each pod (necessary to select them during the assignment of a task to a robot)
int pods[PODS_N][3];

// task_queue is global so that the process Robot and the process Task_Queue can synchronize on it.
int current_length_queue = 0;
int task_queue[MAX_T];


// CHANNELS OF THE MODEL

// Array of channels, where the id of the array corresponds to the pod_id, chosen unambigously during the intialization of the map.
chan pods_channel[PODS_N];

// Channels which synchronize when the human takes the item and the robot gives the item.
chan human_pick_up;
chan free_robot;





const int entryPoint[2] = {N-1,M-1};
const int deliveryPoint[2] = {0,M-1};

//We want to be sure to initialize everything to zero
void initialize_grid() {
    int i,j;

    for (i=0; i&lt;N; i++) {
        for (j=0; j&lt;M; j++) {
            grid[i][j] = 0;
        }
    }
}

void place_pods() {
    int i,j;

    int pod_id = 0;
    
    for (i=0; i&lt;N; i+=2) {
        for (j=0; j&lt;M-4; j++) {
            grid[i][j] = POD;
            pods[pod_id][0] = i;
            pods[pod_id][1] = j;
            pods[pod_id][2] = POD_FREE;
            pod_id++;
        }
    }
}</declaration>
	<template>
		<name>Task_Queue</name>
		<parameter>int T</parameter>
		<declaration>clock t;


// It returns the number of pods available in this instant.
// It is used in the select of a random pod.
int free_pods_number() {
    int number = 0;

    int pod_id;

    for (pod_id = 0; pod_id&lt;N; pod_id++) {
        if (pods[pod_id][2] == POD_FREE) {
            number++;
        }
    }

    return number;
}

// Add a task w.r.t. the id pod RELATIVE to the number of free pods.
// It means that the id pod is the n-th available pod in the array `pods`.
void add_task(int id) {
    int id_pod_relative = id%free_pods_number();
    int count_id_rel = 0;

    bool pod_found = false;
    int id_pod=0;
    
    while (id_pod&lt;PODS_N &amp;&amp; !pod_found) {

        if (pods[id_pod][2] = POD_FREE) {

            if (count_id_rel == id_pod_relative)
                pod_found = true;

            count_id_rel++;
        }

        id_pod++;
    }
    id_pod--;    // put here because in the while it counts once more the necessary

    
    task_queue[current_length_queue] = id_pod;
    current_length_queue++;

    pods[id_pod][2] = POD_OCCUPIED;
}

void remove_task() {
    int i;

    for (i=1; i&lt;current_length_queue; i++) {
        task_queue[i-1] = task_queue[i];
    }

    task_queue[current_length_queue - 1] = -1;
    current_length_queue--;
}

void initialize_task_queue() {
    int i;

    for (i=0; i&lt;MAX_T; i++) {
        task_queue[i] = -1; // TODO
    }
}

bool pod_available(int id_pod) {
    return pods[id_pod][2] == POD_FREE;
}


</declaration>
		<location id="id0" x="-714" y="0">
			<name x="-724" y="-34">start</name>
		</location>
		<location id="id1" x="-323" y="0">
			<name x="-365" y="-42">task_generation</name>
			<label kind="invariant" x="-374" y="0">t &lt;= T</label>
		</location>
		<location id="id2" x="-493" y="204">
			<name x="-578" y="229">Err_podsUnavailable</name>
		</location>
		<location id="id3" x="-323" y="204">
			<name x="-331" y="229">Error_maxSizeReached</name>
		</location>
		<location id="id4" x="238" y="0">
			<name x="228" y="-34">task_sent</name>
			<label kind="invariant" x="228" y="17">t &lt; T</label>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="-705" y="110">current_length_queue&lt;MAX_T
&amp;&amp; t==T &amp;&amp; free_pods_number()==0</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="guard" x="-306" y="127">current_length_queue&gt;=MAX_T 
&amp;&amp; t==T</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id1"/>
			<label kind="guard" x="34" y="76">t &lt; T</label>
			<label kind="assignment" x="0" y="93">remove_task()</label>
			<nail x="85" y="76"/>
			<nail x="-204" y="76"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-153" y="-34">current_length_queue&gt;0 &amp;&amp; t&lt;T</label>
			<label kind="synchronisation" x="-144" y="-59">pods_channel[task_queue[0]]?</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="select" x="-399" y="-221">id_pod_relative : int[0 , PODS_N]</label>
			<label kind="guard" x="-399" y="-195">current_length_queue&lt;MAX_T
&amp;&amp; t==T &amp;&amp; free_pods_number() &gt; 0</label>
			<label kind="assignment" x="-416" y="-144">add_task(id_pod_relative),
t = 0</label>
			<nail x="-373" y="-76"/>
			<nail x="-280" y="-76"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-612" y="-85">t = 0,
initialize_grid(),
place_pods(),
initialize_task_queue()</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Robot</name>
		<parameter>int K</parameter>
		<declaration>clock t;

const int ALONE = 0;
const int CARRYING_POD = 1;

int robot_status = ALONE;

// Current robot position
int robot_position[2] = {entryPoint[0], entryPoint[1]};

// Current task's pod
int pod_id = -1;

// Cell's coordinates at previous position, used to avoid moving back and forth
int saved_cell[2] = {entryPoint[0], entryPoint[1]};

int manhattan_distance(int x_source, int y_source, int x_dest, int y_dest){
	return abs(x_source - x_dest) + abs(y_source - y_dest);
}


bool is_on_entry(){
	return robot_position[0] == entryPoint[0] &amp;&amp; robot_position[1] == entryPoint[1];
}


bool is_under_right_pod(){
	return robot_position[0] == pods[pod_id][0] &amp;&amp; robot_position[1] == pods[pod_id][1];
}


bool is_on_delivery(){
	return robot_position[0] == deliveryPoint[0] &amp;&amp; robot_position[1] == deliveryPoint[1];
}


bool cell_available(int x_coordinate, int y_coordinate, bool allowedEntry) {
	bool is_entry_point = (x_coordinate == entryPoint[0] &amp;&amp; y_coordinate == entryPoint[1]);
	if (!is_entry_point){
	    if (robot_status == ALONE)
	        return  x_coordinate &gt;= 0 &amp;&amp; x_coordinate &lt; N &amp;&amp; y_coordinate &gt;= 0 &amp;&amp; y_coordinate &lt; M &amp;&amp;
	                (grid[x_coordinate][y_coordinate] == EMPTY || grid[x_coordinate][y_coordinate] ==  POD);

	    if (robot_status == CARRYING_POD)
	        return  x_coordinate &gt;= 0 &amp;&amp; x_coordinate &lt; N &amp;&amp; y_coordinate &gt;= 0 &amp;&amp; y_coordinate &lt; M &amp;&amp;
	                grid[x_coordinate][y_coordinate] == EMPTY;
	} else{
		return allowedEntry;
	}

    return false;
}


void move_to(int x_dest, int y_dest, bool allowedEntry){
	int x_robot = robot_position[0];
	int y_robot = robot_position[1];

	int minimum_distance = N + M + 1;
	int movement_direction[2] = {0, 0};

    int previous_cell;
    int current_cell;

    int i, j;
    int temp_distance;

	for (i = -1; i&lt;=1; i++){
		for (j = -1; j&lt;=1; j++){
			if ((i == 0 || j == 0) &amp;&amp; (i != 0 || j != 0)){ // the robot cannot move diagonally
				temp_distance = manhattan_distance(x_robot + i, y_robot + j, x_dest, y_dest);
				if (cell_available(x_robot + i, y_robot + j, allowedEntry) &amp;&amp; temp_distance &lt; minimum_distance){
					if (saved_cell[0] != x_robot + i || saved_cell[1] != y_robot + j){
						minimum_distance = temp_distance;
						movement_direction[0] = i;
						movement_direction[1] = j;
					}
				}
			}
		}
	}

	if (movement_direction[0] == 0 &amp;&amp; movement_direction[1] == 0 &amp;&amp; cell_available(saved_cell[0], saved_cell[1], allowedEntry)){
		movement_direction[0] = saved_cell[0] - x_robot;
		movement_direction[1] = saved_cell[1] - y_robot;
	}

	// If the robot is moving, the previous cell is saved
	if (movement_direction[0] != 0 || movement_direction[1] != 0){
		saved_cell[0] = x_robot;
		saved_cell[1] = y_robot;
	}

	previous_cell = grid[x_robot][y_robot];
    current_cell = grid[x_robot + movement_direction[0]][y_robot + movement_direction[1]];

    robot_position[0] = x_robot + movement_direction[0];
    robot_position[1] = y_robot + movement_direction[1];
    // The robot can't move
    if (movement_direction[0] == 0 &amp;&amp; movement_direction[1] == 0)
        return;

    if (robot_status != CARRYING_POD) {
        // Depending on what was the previous position's status, it changes because the robot leaves the cell
        if (previous_cell == ROBOT)     previous_cell = EMPTY;
        else if (previous_cell == POD_AND_ROBOT)    previous_cell = POD;
        // Depending of what was the current position's status, it changes because the robot enters the cell
        if (current_cell == EMPTY)  current_cell = ROBOT;
        else if (current_cell == POD)   current_cell = POD_AND_ROBOT;
    }
    else {
        // Previous cell always empty
        previous_cell = EMPTY;
        // The robot is carrying the pod
        current_cell = POD_AND_ROBOT;
    }

	grid[x_robot][y_robot] = previous_cell;

	if(x_robot + movement_direction[0] != entryPoint[0] || y_robot + movement_direction[1] != entryPoint[1]){
		grid[x_robot + movement_direction[0]][y_robot + movement_direction[1]] = current_cell;
	}

    return;
}

void go_to_pod(){
	int x_pod = pods[pod_id][0];
	int y_pod = pods[pod_id][1];
    	move_to(x_pod, y_pod, false);
    return;
}

void go_to_delivery(){
	move_to(deliveryPoint[0], deliveryPoint[1], false);
    return;
}

void go_to_entry(){
	if (is_on_entry())
		return;
    move_to(entryPoint[0], entryPoint[1], true);
    return;
}
</declaration>
		<location id="id5" x="-629" y="-187">
			<name x="-639" y="-221">start</name>
			<label kind="invariant" x="-646" y="-170">t &lt;= K</label>
		</location>
		<location id="id6" x="-348" y="-297">
			<name x="-391" y="-263">reaching_pod</name>
			<label kind="invariant" x="-365" y="-280">t &lt;= K</label>
		</location>
		<location id="id7" x="-68" y="-178">
			<name x="-102" y="-221">delivering</name>
			<label kind="invariant" x="-136" y="-178">t &lt;= K</label>
		</location>
		<location id="id8" x="-357" y="-51">
			<name x="-391" y="-102">back_to_pod</name>
			<label kind="invariant" x="-374" y="-85">t &lt;= K</label>
		</location>
		<location id="id9" x="-68" y="-51">
			<name x="-42" y="-42">standby</name>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-238" y="-42">free_robot?</label>
			<label kind="assignment" x="-221" y="-25">t = 0</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="guard" x="-51" y="-119">is_on_delivery()</label>
			<label kind="synchronisation" x="-51" y="-93">human_pick_up!</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id5"/>
			<label kind="guard" x="-816" y="-187">t==K</label>
			<label kind="assignment" x="-858" y="-212">go_to_entry(), t=0</label>
			<nail x="-714" y="-153"/>
			<nail x="-714" y="-238"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id5"/>
			<label kind="guard" x="-637" y="-127">is_under_right_pod()</label>
			<label kind="assignment" x="-654" y="-110">robot_status = ALONE, t=0</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id8"/>
			<label kind="guard" x="-450" y="51">t==K &amp;&amp; !is_under_right_pod()</label>
			<label kind="assignment" x="-408" y="34">go_to_pod(), t=0</label>
			<nail x="-297" y="25"/>
			<nail x="-425" y="25"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id7"/>
			<label kind="guard" x="102" y="-170">t==K &amp;&amp; !is_on_delivery()</label>
			<label kind="assignment" x="119" y="-195">go_to_delivery(), t=0</label>
			<nail x="85" y="-229"/>
			<nail x="85" y="-127"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="-212" y="-297">is_under_right_pod() &amp;&amp; t&lt;K</label>
			<label kind="assignment" x="-229" y="-272">robot_status = CARRYING_POD</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="guard" x="-425" y="-391">t==K &amp;&amp; !is_under_right_pod()</label>
			<label kind="assignment" x="-399" y="-374">go_to_pod(), t=0</label>
			<nail x="-390" y="-348"/>
			<nail x="-297" y="-348"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="-688" y="-323">current_length_queue &gt; 0 &amp;&amp; is_on_entry()</label>
			<label kind="synchronisation" x="-637" y="-306">pods_channel[task_queue[0]]!</label>
			<label kind="assignment" x="-629" y="-289">t=0, pod_id = task_queue[0]</label>
		</transition>
	</template>
	<template>
		<name>Human</name>
		<parameter>int H</parameter>
		<declaration>// Place local declarations here.
clock t;</declaration>
		<location id="id10" x="-297" y="-51">
			<name x="-307" y="-85">idle</name>
		</location>
		<location id="id11" x="-34" y="-51">
			<name x="-34" y="-85">pick_up_item</name>
			<label kind="invariant" x="-44" y="-34">t &lt;= H</label>
		</location>
		<init ref="id10"/>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="-187" y="34">t == H</label>
			<label kind="synchronisation" x="-204" y="51">free_robot!</label>
			<nail x="-85" y="25"/>
			<nail x="-238" y="25"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-212" y="-170">human_pick_up?</label>
			<label kind="assignment" x="-178" y="-153">t = 0</label>
			<nail x="-229" y="-127"/>
			<nail x="-93" y="-127"/>
		</transition>
	</template>
	<system>const int T = 5;
const int H = 1;
const int K = 2;

// Place template instantiations here.
human = Human(H);
task_queue_process = Task_Queue(T);
robotA = Robot(K);
robotB = Robot(K);
robotC = Robot(K);

// List one or more processes to be composed into a system.
system human, task_queue_process, robotA, robotB, robotC;</system>
	<queries>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
	</queries>
</nta>
