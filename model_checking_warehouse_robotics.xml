<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.

// Grid dimension
const int N=10;
const int M=10;

// These are the cell states, to understand whether it is occupied or not.
const int EMPTY = 0;
const int ROBOT = 1;
const int POD = 2;
const int POD_AND_ROBOT = 3;

// Status of the pod.
const int POD_FREE = 0;
const int POD_OCCUPIED = 1;

// Max number of tasks
const int MAX_T = 20;

// Upper bound for deterministic simulation purposes
// const int SIM_MAX_T = 1 * MAX_T;

// Overall count of tasks created (deterministic simulation purposes)
// int total_tasks_number = 0;

// Number of pods
const int PODS_N = N*M - (N/2)*M - (N/2 + N%2)*4;

// Invalid pod
const int POD_ERR = 0;

// This is the grid representing the map.
int grid[N][M];

// Position and status of each pod.
// The second array is necessary to understand the position of the pod and the status (free/occupied).
// The first array is simply a way of giving the id to each pod (necessary to select them during the assignment of a task to a robot)
int pods[PODS_N][3];

// task_queue is global so that the process Robot and the process Task_Queue can synchronize on it.
int current_length_queue = 0;
int task_queue[MAX_T];


// CHANNELS OF THE MODEL

// Array of channels, where the id of the array corresponds to the pod_id, chosen unambigously during the intialization of the map.
broadcast chan pods_channel[PODS_N];

// Channels which synchronize when the human takes the item and the robot gives the item.
urgent broadcast chan human_pick_up;
broadcast chan free_robot;




const int entryPoint[2] = {N-1,M-1};
const int deliveryPoint[2] = {0,M-1};

const double PI = 3.14159265358979323846;

// Time bound for stochastic features
const int TAU = 750;

// Normal distribution functions for SMC extensions
double stdNormal() {// N(0, 1)
    return sqrt(-2*ln(1-random(1))) * cos(2*PI*random(1));
}
double Normal(double mean, double stdDev) {
    return mean + stdDev * stdNormal();
}

//We want to be sure to initialize everything to zero
void initialize_grid() {
    int i,j;

    for (i=0; i&lt;N; i++) {
        for (j=0; j&lt;M; j++) {
            grid[i][j] = 0;
        }
    }
}

void place_pods() {
    int i,j;

    int pod_id = 0;
    
    for (i=0; i&lt;N; i+=2) {
        for (j=0; j&lt;M-4; j++) {
            grid[i][j] = POD;
            pods[pod_id][0] = i;
            pods[pod_id][1] = j;
            pods[pod_id][2] = POD_FREE;
            pod_id++;
        }
    }
}</declaration>
	<template>
		<name>Task_Queue</name>
		<parameter>double m, double v</parameter>
		<declaration>clock t;

clock task_delay;

// It returns the number of pods available in this instant.
// It is used in the select of a random pod.
int free_pods_number() {
    int number = 0;

    int pod_id;

    for (pod_id = 0; pod_id&lt;PODS_N; pod_id++) {
        if (pods[pod_id][2] == POD_FREE) {
            number++;
        }
    }

    return number;
}

// Add a task w.r.t. the id pod RELATIVE to the number of free pods.
// It means that the id pod is the n-th available pod in the array `pods`.
void add_task(int id) {
    int id_pod_relative = id%free_pods_number();
    int count_id_rel = 0;

    bool pod_found = false;
    int id_pod=0;
    
    while (id_pod&lt;PODS_N &amp;&amp; !pod_found) {

        if (pods[id_pod][2] == POD_FREE) {

            if (count_id_rel == id_pod_relative)
                pod_found = true;

            count_id_rel++;
        }

        id_pod++;
    }
    id_pod--;    // put here because in the while it counts once more the necessary

    
    task_queue[current_length_queue] = id_pod;
    current_length_queue++;

    pods[id_pod][2] = POD_OCCUPIED;
}

void remove_task() {
    int i;

    for (i=1; i&lt;current_length_queue; i++) {
        task_queue[i-1] = task_queue[i];
    }

    task_queue[current_length_queue - 1] = POD_ERR;
    current_length_queue--;
}

void initialize_task_queue() {
    int i;

    for (i=0; i&lt;MAX_T; i++) {
        task_queue[i] = POD_ERR; // TODO
    }
}

bool pod_available(int id_pod) {
    return pods[id_pod][2] == POD_FREE;
}

// Add delay in creation of tasks (normal distribution)
double compute_task_delay(){
    return fabs(Normal(m, v));
}</declaration>
		<location id="id0" x="-714" y="0">
			<name x="-724" y="-34">start</name>
			<label kind="invariant" x="-724" y="17">t &lt;= 0</label>
		</location>
		<location id="id1" x="-323" y="0">
			<name x="-365" y="-42">task_generation</name>
			<label kind="invariant" x="-561" y="17">t &lt;= task_delay &amp;&amp; task_delay'==0</label>
		</location>
		<location id="id2" x="-518" y="204">
			<name x="-603" y="229">Err_podsUnavailable</name>
		</location>
		<location id="id3" x="-323" y="204">
			<name x="-374" y="229">Error_maxSizeReached</name>
		</location>
		<location id="id4" x="238" y="0">
			<name x="228" y="-34">task_sent</name>
			<label kind="invariant" x="212" y="17">t &lt;= task_delay &amp;&amp; task_delay'==0</label>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="-730" y="144">current_length_queue&lt;MAX_T
&amp;&amp; t==task_delay &amp;&amp; free_pods_number()==0</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="guard" x="-416" y="136">current_length_queue&gt;=MAX_T 
&amp;&amp; t==task_delay</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id1"/>
			<label kind="guard" x="0" y="76">t &lt;= task_delay</label>
			<label kind="assignment" x="0" y="93">remove_task()</label>
			<nail x="85" y="76"/>
			<nail x="-204" y="76"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-136" y="-42">current_length_queue&gt;0</label>
			<label kind="synchronisation" x="-144" y="-59">pods_channel[task_queue[0]]?</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="select" x="-416" y="-204">id_pod_relative : int[0 , PODS_N-1]</label>
			<label kind="guard" x="-416" y="-187">current_length_queue&lt;MAX_T
&amp;&amp; t==task_delay &amp;&amp; free_pods_number() &gt; 0</label>
			<label kind="assignment" x="-416" y="-127">add_task(id_pod_relative),
t = 0, task_delay = compute_task_delay()</label>
			<nail x="-373" y="-76"/>
			<nail x="-280" y="-76"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-663" y="-102">t = 0,
task_delay = compute_task_delay(),
initialize_grid(),
place_pods(),
initialize_task_queue()</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Robot</name>
		<parameter>int K</parameter>
		<declaration>clock t;

const int ALONE = 0;
const int CARRYING_POD = 1;

int robot_status = ALONE;

// Current robot position
int robot_position[2] = {entryPoint[0], entryPoint[1]};

// Current task's pod
int pod_id = POD_ERR;

// Cell's coordinates at previous position, used to avoid moving back and forth
int saved_cell[2] = {entryPoint[0], entryPoint[1]};

int manhattan_distance(int x_source, int y_source, int x_dest, int y_dest){
	return abs(x_source - x_dest) + abs(y_source - y_dest);
}


bool is_on_entry(){
	return robot_position[0] == entryPoint[0] &amp;&amp; robot_position[1] == entryPoint[1];
}


bool is_under_right_pod(){
	return robot_position[0] == pods[pod_id][0] &amp;&amp; robot_position[1] == pods[pod_id][1];
}


bool is_on_delivery(){
	return robot_position[0] == deliveryPoint[0] &amp;&amp; robot_position[1] == deliveryPoint[1];
}


bool cell_available(int x_coordinate, int y_coordinate, bool allowedEntry) {
	bool is_entry_point = (x_coordinate == entryPoint[0] &amp;&amp; y_coordinate == entryPoint[1]);
	if (!is_entry_point){
	    if (robot_status == ALONE)
	        return  x_coordinate &gt;= 0 &amp;&amp; x_coordinate &lt; N &amp;&amp; y_coordinate &gt;= 0 &amp;&amp; y_coordinate &lt; M &amp;&amp;
	                (grid[x_coordinate][y_coordinate] == EMPTY || grid[x_coordinate][y_coordinate] ==  POD);

	    if (robot_status == CARRYING_POD)
	        return  x_coordinate &gt;= 0 &amp;&amp; x_coordinate &lt; N &amp;&amp; y_coordinate &gt;= 0 &amp;&amp; y_coordinate &lt; M &amp;&amp;
	                grid[x_coordinate][y_coordinate] == EMPTY;
	} else{
		return allowedEntry;
	}

    return false;
}


void move_to(int x_dest, int y_dest, bool allowedEntry){
	int x_robot = robot_position[0];
	int y_robot = robot_position[1];

	int minimum_distance = N + M + 1;
	int movement_direction[2] = {0, 0};

    int previous_cell;
    int current_cell;

    int i, j;
    int temp_distance;

	for (j = 1; j&gt;=-1; j--){
		for (i = 1; i&gt;=-1; i--){
			if ((i == 0 || j == 0) &amp;&amp; (i != 0 || j != 0)){ // the robot cannot move diagonally
				temp_distance = manhattan_distance(x_robot + i, y_robot + j, x_dest, y_dest);
				if (cell_available(x_robot + i, y_robot + j, allowedEntry) &amp;&amp; temp_distance &lt; minimum_distance){
					if (saved_cell[0] != x_robot + i || saved_cell[1] != y_robot + j){
						minimum_distance = temp_distance;
						movement_direction[0] = i;
						movement_direction[1] = j;
					}
				}
			}
		}
	}

	if (movement_direction[0] == 0 &amp;&amp; movement_direction[1] == 0 &amp;&amp; cell_available(saved_cell[0], saved_cell[1], allowedEntry)){
		movement_direction[0] = saved_cell[0] - x_robot;
		movement_direction[1] = saved_cell[1] - y_robot;
	}

	// If the robot is moving, the previous cell is saved
	if (movement_direction[0] != 0 || movement_direction[1] != 0){
		saved_cell[0] = x_robot;
		saved_cell[1] = y_robot;
	}

	previous_cell = grid[x_robot][y_robot];
    current_cell = grid[x_robot + movement_direction[0]][y_robot + movement_direction[1]];

    robot_position[0] = x_robot + movement_direction[0];
    robot_position[1] = y_robot + movement_direction[1];
    // The robot can't move
    if (movement_direction[0] == 0 &amp;&amp; movement_direction[1] == 0)
        return;

    if (robot_status != CARRYING_POD) {
        // Depending on what was the previous position's status, it changes because the robot leaves the cell
        if (previous_cell == ROBOT)     previous_cell = EMPTY;
        else if (previous_cell == POD_AND_ROBOT)    previous_cell = POD;
        // Depending of what was the current position's status, it changes because the robot enters the cell
        if (current_cell == EMPTY)  current_cell = ROBOT;
        else if (current_cell == POD)   current_cell = POD_AND_ROBOT;
    }
    else {
        // Previous cell always empty
        previous_cell = EMPTY;
        // The robot is carrying the pod
        current_cell = POD_AND_ROBOT;
    }

	grid[x_robot][y_robot] = previous_cell;

	if(x_robot + movement_direction[0] != entryPoint[0] || y_robot + movement_direction[1] != entryPoint[1]){
		grid[x_robot + movement_direction[0]][y_robot + movement_direction[1]] = current_cell;
	}

    return;
}

void go_to_pod(){
	int x_pod = pods[pod_id][0];
	int y_pod = pods[pod_id][1];
    	move_to(x_pod, y_pod, false);
    return;
}

void go_to_delivery(){
	move_to(deliveryPoint[0], deliveryPoint[1], false);
    return;
}

void go_to_entry(){
	if (is_on_entry())
		return;
    move_to(entryPoint[0], entryPoint[1], true);
    return;
}
</declaration>
		<location id="id5" x="-816" y="-51">
			<name x="-826" y="-85">start</name>
			<label kind="exponentialrate" x="-826" y="-17">1</label>
		</location>
		<location id="id6" x="-348" y="-297">
			<name x="-391" y="-263">reaching_pod</name>
			<label kind="invariant" x="-365" y="-280">t &lt;= K</label>
		</location>
		<location id="id7" x="-68" y="-178">
			<name x="-102" y="-221">delivering</name>
			<label kind="invariant" x="-136" y="-178">t &lt;= K</label>
		</location>
		<location id="id8" x="-357" y="-51">
			<name x="-391" y="-102">back_to_pod</name>
			<label kind="invariant" x="-374" y="-85">t &lt;= K</label>
		</location>
		<location id="id9" x="-68" y="-51">
			<name x="-42" y="-42">standby</name>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-238" y="-42">free_robot?</label>
			<label kind="assignment" x="-221" y="-25">t = 0</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="guard" x="-51" y="-119">is_on_delivery()</label>
			<label kind="synchronisation" x="-51" y="-93">human_pick_up!</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id5"/>
			<label kind="guard" x="-1088" y="-76">current_length_queue &lt;= 0</label>
			<label kind="assignment" x="-952" y="-34">t=0</label>
			<nail x="-901" y="-17"/>
			<nail x="-901" y="-102"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id5"/>
			<label kind="guard" x="-680" y="-42">is_under_right_pod()</label>
			<label kind="assignment" x="-680" y="-25">robot_status = ALONE,
pods[pod_id][2] = POD_FREE,
pod_id = POD_ERR,
t=0</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id8"/>
			<label kind="guard" x="-450" y="51">t==K &amp;&amp; !is_under_right_pod()</label>
			<label kind="assignment" x="-408" y="34">go_to_pod(), t=0</label>
			<nail x="-297" y="25"/>
			<nail x="-425" y="25"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id7"/>
			<label kind="guard" x="102" y="-170">t==K &amp;&amp; !is_on_delivery()</label>
			<label kind="assignment" x="119" y="-195">go_to_delivery(), t=0</label>
			<nail x="85" y="-229"/>
			<nail x="85" y="-127"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="-212" y="-297">is_under_right_pod() &amp;&amp; t&lt;=K</label>
			<label kind="assignment" x="-229" y="-272">robot_status = CARRYING_POD</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="guard" x="-425" y="-391">t==K &amp;&amp; !is_under_right_pod()</label>
			<label kind="assignment" x="-399" y="-374">go_to_pod(), t=0</label>
			<nail x="-390" y="-348"/>
			<nail x="-297" y="-348"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="-731" y="-246">current_length_queue &gt; 0</label>
			<label kind="synchronisation" x="-739" y="-229">pods_channel[task_queue[0]]!</label>
			<label kind="assignment" x="-731" y="-212">t=0, pod_id = task_queue[0]</label>
		</transition>
	</template>
	<template>
		<name>Human</name>
		<parameter>double m, double v</parameter>
		<declaration>// Place local declarations here.
clock t;

clock human_delay;

// Add delay in human action
double compute_human_delay(){
    return fabs(Normal(m, v));
}</declaration>
		<location id="id10" x="-297" y="-51">
			<name x="-307" y="-85">idle</name>
		</location>
		<location id="id11" x="-34" y="-51">
			<name x="-34" y="-85">pick_up_item</name>
			<label kind="invariant" x="-44" y="-34">t &lt;= human_delay &amp;&amp; human_delay' == 0</label>
		</location>
		<init ref="id10"/>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="-195" y="34">t == human_delay</label>
			<label kind="synchronisation" x="-195" y="51">free_robot!</label>
			<label kind="assignment" x="-195" y="68">t = 0</label>
			<nail x="-85" y="25"/>
			<nail x="-238" y="25"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-212" y="-170">human_pick_up?</label>
			<label kind="assignment" x="-255" y="-153">t = 0, human_delay = compute_human_delay()</label>
			<nail x="-229" y="-127"/>
			<nail x="-93" y="-127"/>
		</transition>
	</template>
	<system>const double mT = 28.0;
const double vT = 3.0;
const double mH = 1.0;
const double vH = 2.0;
const int K = 2;

// Place template instantiations here.
human = Human(mH, vH);
task_queue_process = Task_Queue(mT, vT);
robotA = Robot(K);
robotB = Robot(K);
robotC = Robot(K);
robotD = Robot(K);
robotE = Robot(K);
robotF = Robot(K);

// List one or more processes to be composed into a system.
system human, task_queue_process, robotA, robotB, robotC, robotD, robotE, robotF;</system>
	<queries>
		<query>
			<formula>Pr[&lt;=TAU] (&lt;&gt; task_queue_process.Err_podsUnavailable)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=TAU] (&lt;&gt; human.pick_up_item)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>simulate[&lt;=TAU; 10]{task_queue_process.task_sent*3}</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=TAU] (&lt;&gt; task_queue_process.Error_maxSizeReached)</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
